Map.centerObject(bnd, 8);

// Selecting the pre-monsoon or pre-flood Copernicus Sentinel-1 
var preFloodSentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')
  .filterDate('2024-01-01', '2024-03-30')
  .filterBounds(bnd);

// Filtering pre-flood Copernicus Sentinel-1 image by metadata properties.
var preFloodVH_VV = preFloodSentinel1
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  .filter(ee.Filter.eq('instrumentMode', 'IW'));

// Filtering to get Sentinel-1 images from different look angles for pre-flood.
var preFloodVH_VVAscend = preFloodVH_VV.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'));
var preFloodVH_VVDescend = preFloodVH_VV.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));

// Combine ascending and descending images and calculate mean
var preFloodComposite = ee.Image.cat([
  preFloodVH_VVAscend.select('VH').mean().rename('VHPre'),
  ee.ImageCollection(preFloodVH_VVAscend.select('VV').merge(preFloodVH_VVDescend.select('VV'))).mean().rename('VVPre'),
  preFloodVH_VVDescend.select('VH').mean().rename('VHPre')
]).focal_median(100, 'circle', 'meters');

// Selecting the flood Copernicus Sentinel-1 
var floodSentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')
  .filterDate('2024-08-21', '2024-08-22')
  .filterBounds(bnd);

print(floodSentinel1)
// Filtering flood time Copernicus Sentinel-1 image by metadata properties.
var floodVH_VV = floodSentinel1
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
  .filter(ee.Filter.eq('instrumentMode', 'IW'));

// Filtering flood time Copernicus Sentinel-1 image from different look angles.
var floodVH_VVAscend = floodVH_VV.filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'));
var floodVH_VVDescend = floodVH_VV.filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'));

// Create a composite from means at different polarizations and look angles.
var floodComposite = ee.Image.cat([
  floodVH_VVAscend.select('VH').mean(),
  ee.ImageCollection(floodVH_VVAscend.select('VV').merge(floodVH_VVDescend.select('VV'))).mean(),
  floodVH_VVDescend.select('VH').mean()
]).focal_median();

// Apply speckle filtering to the Sentinel-1 images
var smoothedVV_Flood = floodComposite.select('VV').focal_median(100, 'circle', 'meters').rename('VVFlood_Smoothed');
var smoothedVH_Flood = floodComposite.select('VH').focal_median(100, 'circle', 'meters').rename('VHFlood_Smoothed');

// Calculate the VV/VH ratio using smoothed bands
var floodVV_VHRatio = smoothedVV_Flood.divide(smoothedVH_Flood).rename('VVVH_Flood_Ratio');

// Apply median smoothing to the VV/VH ratio
var smoothedVVVHRatio_Flood = floodVV_VHRatio.focal_median(100, 'circle', 'meters').rename('VVVH_Flood_Smoothed');

// Calculate the difference between pre-flood and flood VV
var smoothedVV_PreFlood = preFloodComposite.select('VVPre').focal_median(100, 'circle', 'meters').rename('VVPre_Smoothed');
var smoothedVH_PreFlood = preFloodComposite.select('VHPre').focal_median(100, 'circle', 'meters').rename('VHPre_Smoothed');
var vvDifferenceFlood = smoothedVV_PreFlood.subtract(smoothedVV_Flood).rename('VVDifference_Flood_Smoothed');

// Create and add RGB composite and Flood Image Composite layers
var rgbComposite = ee.Image.cat([smoothedVV_PreFlood, smoothedVH_Flood, vvDifferenceFlood]);
var floodImageComposite = ee.Image.cat([smoothedVV_Flood, smoothedVV_PreFlood, vvDifferenceFlood, smoothedVH_Flood]);

Map.addLayer(rgbComposite.clip(bnd), {
  bands: ['VVPre_Smoothed', 'VHFlood_Smoothed', 'VVDifference_Flood_Smoothed'],
  min: [-25, -25, 0],
  max: [0, 0, 10],
  gamma: 1.5
}, 'Sentinel RGB Composite');

 

// Masking normal water bodies using VV PreFlood
var waterMask_PreFlood = smoothedVV_PreFlood.updateMask(smoothedVV_PreFlood.lt(-17)).toUint16();

var floodVisualization = {min: 1, max: 3, palette: ['#3caadc', '007f00', '007f00']};

// Flood masking and mosaicking the Sentinel-1 image
var classifiedFlood = ee.ImageCollection([
  smoothedVV_Flood.updateMask(smoothedVV_Flood.lt(-15.94)).visualize(floodVisualization),
  smoothedVH_Flood.updateMask(smoothedVH_Flood.lt(-24.06)).visualize(floodVisualization),
  smoothedVVVHRatio_Flood.updateMask(smoothedVVVHRatio_Flood.lt(-28)).visualize(floodVisualization),
  waterMask_PreFlood.visualize({palette: ['BLUE']})
]).mosaic();

// Visualization parameters for Sentinel backscatter



Map.addLayer(classifiedFlood.clip(bnd), {}, 'Flood Map Pixel Based');

// Define water points (assuming these are defined elsewhere)
var waterPoints = ee.FeatureCollection(water);

// Extract and analyze values at the points for water pixels
var sampledWaterPoints = smoothedVV_Flood.addBands(smoothedVH_Flood).sampleRegions({
  collection: waterPoints,
  scale: 30,
  geometries: true
});

// Define reducers to calculate the min, max, mean, and median
var minReducer = ee.Reducer.min();
var maxReducer = ee.Reducer.max();
var meanReducer = ee.Reducer.mean();
var medianReducer = ee.Reducer.median();

// Function to extract statistics
function getStats(sampledPoints, band) {
  var min = sampledPoints.reduceColumns(minReducer, [band]).get('min');
  var max = sampledPoints.reduceColumns(maxReducer, [band]).get('max');
  var mean = sampledPoints.reduceColumns(meanReducer, [band]).get('mean');
  var median = sampledPoints.reduceColumns(medianReducer, [band]).get('median');
  return ee.Dictionary({min: min, max: max, mean: mean, median: median});
}

// Extract stats for VV and VH for water points
var waterStats_VV = getStats(sampledWaterPoints, 'VVFlood_Smoothed');
var waterStats_VH = getStats(sampledWaterPoints, 'VHFlood_Smoothed');

// Function to create features for chart
function createFeature(stats, label, band) {
  return ee.Feature(null, {
    label: label + ' ' + band,
    min: stats.get('min'),
    mean: stats.get('mean'),
    median: stats.get('median'),
    max: stats.get('max')
  });
}

// Create features for water points based on VV and VH statistics
var waterVVFeature = createFeature(waterStats_VV, 'Water VV', 'VV');
var waterVHFeature = createFeature(waterStats_VH, 'Water VH', 'VH');

// Combine the features into a FeatureCollection
var featureCollection = ee.FeatureCollection([waterVVFeature, waterVHFeature]);

// Create a chart showing min, mean, median, and max for VV and VH
var chart = ui.Chart.feature.byFeature(featureCollection, 'label', ['min', 'mean', 'median', 'max'])
  .setChartType('ColumnChart')
  .setOptions({
    title: 'VV and VH Polarization Intervals for Water Points',
    hAxis: {title: 'Statistic'},
    vAxis: {title: 'Backscatter Value (dB)'},
    series: {
      0: {color: 'blue'},   // Min
      1: {color: 'orange'}, // Mean
      2: {color: 'green'},  // Median
      3: {color: 'red'}     // Max
    },
    legend: {position: 'right'}
  });
print(chart);

// Print the statistics for VV and VH
function printAllStats(stats, label) {
  print(label + ' Min:', stats.get('min'));
  print(label + ' Max:', stats.get('max'));
  print(label + ' Mean:', stats.get('mean'));
  print(label + ' Median:', stats.get('median'));
}

// Print VV and VH statistics for water points
printAllStats(waterStats_VV, 'Water Points VV');
printAllStats(waterStats_VH, 'Water Points VH');

// Create a Flood Image Composite using various bands
var finalFloodImageComposite = ee.Image.cat([
  smoothedVV_Flood.rename('VVFlood_Smoothed'), 
  smoothedVH_PreFlood.rename('VHPre_Smoothed'), 
  vvDifferenceFlood.rename('VVDifference_Flood_Smoothed'), 
  floodVV_VHRatio.rename('VVVH_Flood_Ratio'), 
  smoothedVH_Flood.rename('VHFlood_Smoothed'), 
  smoothedVVVHRatio_Flood.rename('VVVH_Flood_Smoothed')
]);

// // Add the Flood Image Composite to the map
// Map.addLayer(finalFloodImageComposite.clip(bnd), {
//   bands: ['VVFlood_Smoothed', 'VHFlood_Smoothed', 'VVVH_Flood_Smoothed'],
//   min: [-25, -25, -10],
//   max: [0, 0, 10],
//   gamma: 1.5
// }, 'Flood Image Composite');

// Merge training sample points together
var trainingSample = flood.merge(water).merge(land);
print(trainingSample, 'Training Sample');

// Select the bands for training
var trainingBands = ['VVFlood_Smoothed', 'VHPre_Smoothed', 'VVDifference_Flood_Smoothed', 'VVVH_Flood_Ratio', 'VHFlood_Smoothed', 'VVVH_Flood_Smoothed'];

// Sample the input imagery to get a FeatureCollection of training data.
var trainingData = finalFloodImageComposite.select(trainingBands).sampleRegions({
  collection: trainingSample,
  properties: ['className'],
  scale: 30
});

// Select a classifier and train it.
var classifier = ee.Classifier.smileCart().train({
  features: trainingData,
  classProperty: 'className',
  inputProperties: trainingBands
});

// Classify the input imagery.
var classifiedFloodRF = finalFloodImageComposite.select(trainingBands).classify(classifier);

// Define a palette for the Land Use classification.
var floodVisualizationRF = ['#3caadc', 'BLUE', '00ad00']


// Add the classified map to the layer
Map.addLayer(classifiedFloodRF.clip(bnd), {min: 1, max: 3, palette: floodVisualizationRF}, 'Flood Map RF');

// Clip all images using the bnd layer (assumed to be an ee.Geometry object)
var clippedRGBComposite = rgbComposite.clip(bnd);
var clippedFloodRF = classifiedFloodRF.clip(bnd);
var clippedFloodPixel = classifiedFlood.clip(bnd);

// ** Export the RGB Composite Image to Google Drive **
Export.image.toDrive({
  image: clippedRGBComposite,  // Clipped RGB composite image
  description: 'Sentinel1_RGB_Composite',
  folder: 'a',  // Specify your Google Drive folder name
  fileNamePrefix: 'Sentinel1_RGB_Composite_2024',  // File name of the exported image
  scale: 10,  // Sentinel-1 resolution scale (adjust if necessary)
  region: bnd,  // Define the region, assuming bnd is an ee.Geometry object
  fileFormat: 'GeoTIFF',
  maxPixels: 1e9  // Adjust this value if the default is too low for your region size
});

// ** Export the Random Forest Classified Flood Map (Flood Map RF) **
Export.image.toDrive({
  image: clippedFloodRF,  // Clipped Flood Map RF (Random Forest)
  description: 'Flood_Map_RF',
  folder: 'a',  // Specify the Google Drive folder name
  fileNamePrefix: 'Flood_Map_RF',  // File name for the exported image
  scale: 10,  // Sentinel-1 resolution scale
  region: bnd,  // Region of interest (bnd should be defined as an ee.Geometry object)
  fileFormat: 'GeoTIFF',
  maxPixels: 1e9  // Adjust this if necessary for larger regions
});

// ** Export the Pixel-Based Flood Map (Flood Map Pixel-Based) **
Export.image.toDrive({
  image: clippedFloodPixel,  // Clipped Pixel-Based Flood Map
  description: 'Flood_Map_PB',
  folder: 'a',  // Specify the Google Drive folder name
  fileNamePrefix: 'Flood_Map_PB',  // File name for the exported image
  scale: 10,  // Sentinel-1 resolution scale
  region: bnd,  // Region of interest (bnd should be defined as an ee.Geometry object)
  fileFormat: 'GeoTIFF',
  maxPixels: 1e9  // Adjust this if necessary for larger regions
});


/*
Kabir Uddin, ICIMOD, Nepal Email: Kabir.Uddin@icimod.org kabir.uddin.bd@gmail.com 
*/
